interface BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!
}

type BaseModel implements BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!
}

type BaseModelUUID implements BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!
}

input BaseWhereInput {
  id_eq: String
  id_in: [String!]
  createdAt_eq: String
  createdAt_lt: String
  createdAt_lte: String
  createdAt_gt: String
  createdAt_gte: String
  createdById_eq: String
  updatedAt_eq: String
  updatedAt_lt: String
  updatedAt_lte: String
  updatedAt_gt: String
  updatedAt_gte: String
  updatedById_eq: String
  deletedAt_all: Boolean
  deletedAt_eq: String
  deletedAt_lt: String
  deletedAt_lte: String
  deletedAt_gt: String
  deletedAt_gte: String
  deletedById_eq: String
}

type Block implements BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!
  block: Int!
  timestamp: Int!
  nework: Network!
  categorys: [Category!]
  channels: [Channel!]
  classEntitys: [ClassEntity!]
  httpMediaLocations: [HttpMediaLocation!]
  joystreamMediaLocations: [JoystreamMediaLocation!]
  knownLicenses: [KnownLicense!]
  languages: [Language!]
  members: [Member!]
  userDefinedLicenses: [UserDefinedLicense!]
  videos: [Video!]
  videoMedias: [VideoMedia!]
}

type BlockConnection {
  totalCount: Int!
  edges: [BlockEdge!]!
  pageInfo: PageInfo!
}

input BlockCreateInput {
  block: Float!
  timestamp: Float!
  nework: Network!
}

type BlockEdge {
  node: Block!
  cursor: String!
}

enum BlockOrderByInput {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  block_ASC
  block_DESC
  timestamp_ASC
  timestamp_DESC
  nework_ASC
  nework_DESC
}

input BlockUpdateInput {
  block: Float
  timestamp: Float
  nework: Network
}

input BlockWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  block_eq: Int
  block_gt: Int
  block_gte: Int
  block_lt: Int
  block_lte: Int
  block_in: [Int!]
  timestamp_eq: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  nework_eq: Network
  nework_in: [Network!]
}

input BlockWhereUniqueInput {
  id: ID!
}

type Category implements BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!

  """The name of the category"""
  name: String!

  """The description of the category"""
  description: String
  happenedIn: Block
  happenedInId: String!
}

type CategoryConnection {
  totalCount: Int!
  edges: [CategoryEdge!]!
  pageInfo: PageInfo!
}

input CategoryCreateInput {
  name: String!
  description: String
  happenedInId: ID!
}

type CategoryEdge {
  node: Category!
  cursor: String!
}

enum CategoryOrderByInput {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  happenedInId_ASC
  happenedInId_DESC
}

input CategoryUpdateInput {
  name: String
  description: String
  happenedInId: ID
}

input CategoryWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  name_eq: String
  name_contains: String
  name_startsWith: String
  name_endsWith: String
  name_in: [String!]
  description_eq: String
  description_contains: String
  description_startsWith: String
  description_endsWith: String
  description_in: [String!]
  happenedInId_eq: ID
  happenedInId_in: [ID!]
}

input CategoryWhereUniqueInput {
  id: ID
  name: String
}

type Channel implements BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!

  """The title of the Channel"""
  title: String!

  """The description of a Channel"""
  description: String!

  """Url for Channel's cover (background) photo. Recommended ratio: 16:9."""
  coverPhotoUrl: String!

  """Channel's avatar photo."""
  avatarPhotoUrl: String!

  """Flag signaling whether a channel is public."""
  isPublic: Boolean!

  """Flag signaling whether a channel is curated/verified."""
  isCurated: Boolean!

  """The primary langauge of the channel's content"""
  languageId: Int
  happenedIn: Block
  happenedInId: String!
}

type ChannelConnection {
  totalCount: Int!
  edges: [ChannelEdge!]!
  pageInfo: PageInfo!
}

input ChannelCreateInput {
  title: String!
  description: String!
  coverPhotoUrl: String!
  avatarPhotoUrl: String!
  isPublic: Boolean!
  isCurated: Boolean!
  languageId: Float
  happenedInId: ID!
}

type ChannelEdge {
  node: Channel!
  cursor: String!
}

enum ChannelOrderByInput {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  title_ASC
  title_DESC
  description_ASC
  description_DESC
  coverPhotoUrl_ASC
  coverPhotoUrl_DESC
  avatarPhotoUrl_ASC
  avatarPhotoUrl_DESC
  isPublic_ASC
  isPublic_DESC
  isCurated_ASC
  isCurated_DESC
  languageId_ASC
  languageId_DESC
  happenedInId_ASC
  happenedInId_DESC
}

input ChannelUpdateInput {
  title: String
  description: String
  coverPhotoUrl: String
  avatarPhotoUrl: String
  isPublic: Boolean
  isCurated: Boolean
  languageId: Float
  happenedInId: ID
}

input ChannelWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  title_eq: String
  title_contains: String
  title_startsWith: String
  title_endsWith: String
  title_in: [String!]
  description_eq: String
  description_contains: String
  description_startsWith: String
  description_endsWith: String
  description_in: [String!]
  coverPhotoUrl_eq: String
  coverPhotoUrl_contains: String
  coverPhotoUrl_startsWith: String
  coverPhotoUrl_endsWith: String
  coverPhotoUrl_in: [String!]
  avatarPhotoUrl_eq: String
  avatarPhotoUrl_contains: String
  avatarPhotoUrl_startsWith: String
  avatarPhotoUrl_endsWith: String
  avatarPhotoUrl_in: [String!]
  isPublic_eq: Boolean
  isPublic_in: [Boolean!]
  isCurated_eq: Boolean
  isCurated_in: [Boolean!]
  languageId_eq: Int
  languageId_gt: Int
  languageId_gte: Int
  languageId_lt: Int
  languageId_lte: Int
  languageId_in: [Int!]
  happenedInId_eq: ID
  happenedInId_in: [ID!]
}

input ChannelWhereUniqueInput {
  id: ID!
}

"""
This type is to keep which entity belongs to which class. This type will be used
by EntityCreated event. When a new schema support added to an Entity we will get the
class name from this table.
We need this because we can't create a database row (Channel, Video etc) without
with empty fields.
"""
type ClassEntity implements BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!

  """The class id of this entity"""
  classId: Int!
  happenedIn: Block
  happenedInId: String!
}

type ClassEntityConnection {
  totalCount: Int!
  edges: [ClassEntityEdge!]!
  pageInfo: PageInfo!
}

input ClassEntityCreateInput {
  classId: Float!
  happenedInId: ID!
}

type ClassEntityEdge {
  node: ClassEntity!
  cursor: String!
}

enum ClassEntityOrderByInput {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  classId_ASC
  classId_DESC
  happenedInId_ASC
  happenedInId_DESC
}

input ClassEntityUpdateInput {
  classId: Float
  happenedInId: ID
}

input ClassEntityWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  classId_eq: Int
  classId_gt: Int
  classId_gte: Int
  classId_lt: Int
  classId_lte: Int
  classId_in: [Int!]
  happenedInId_eq: ID
  happenedInId_in: [ID!]
}

input ClassEntityWhereUniqueInput {
  id: ID!
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

interface DeleteResponse {
  id: ID!
}

type HandlesFTSOutput {
  item: HandlesSearchResult!
  rank: Float!
  isTypeOf: String!
  highlight: String!
}

union HandlesSearchResult = Member

type HttpMediaLocation implements BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!

  """The http url pointing to the media"""
  url: String!

  """The port to use when connecting to the http url (defaults to 80)"""
  port: Int
  happenedIn: Block
  happenedInId: String!
}

type HttpMediaLocationConnection {
  totalCount: Int!
  edges: [HttpMediaLocationEdge!]!
  pageInfo: PageInfo!
}

input HttpMediaLocationCreateInput {
  url: String!
  port: Float
  happenedInId: ID!
}

type HttpMediaLocationEdge {
  node: HttpMediaLocation!
  cursor: String!
}

enum HttpMediaLocationOrderByInput {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  url_ASC
  url_DESC
  port_ASC
  port_DESC
  happenedInId_ASC
  happenedInId_DESC
}

input HttpMediaLocationUpdateInput {
  url: String
  port: Float
  happenedInId: ID
}

input HttpMediaLocationWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  url_eq: String
  url_contains: String
  url_startsWith: String
  url_endsWith: String
  url_in: [String!]
  port_eq: Int
  port_gt: Int
  port_gte: Int
  port_lt: Int
  port_lte: Int
  port_in: [Int!]
  happenedInId_eq: ID
  happenedInId_in: [ID!]
}

input HttpMediaLocationWhereUniqueInput {
  id: ID!
}

type JoystreamMediaLocation implements BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!

  """Id of the data object in the Joystream runtime dataDirectory module"""
  dataObjectId: String!
  happenedIn: Block
  happenedInId: String!
}

type JoystreamMediaLocationConnection {
  totalCount: Int!
  edges: [JoystreamMediaLocationEdge!]!
  pageInfo: PageInfo!
}

input JoystreamMediaLocationCreateInput {
  dataObjectId: String!
  happenedInId: ID!
}

type JoystreamMediaLocationEdge {
  node: JoystreamMediaLocation!
  cursor: String!
}

enum JoystreamMediaLocationOrderByInput {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  dataObjectId_ASC
  dataObjectId_DESC
  happenedInId_ASC
  happenedInId_DESC
}

input JoystreamMediaLocationUpdateInput {
  dataObjectId: String
  happenedInId: ID
}

input JoystreamMediaLocationWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  dataObjectId_eq: String
  dataObjectId_contains: String
  dataObjectId_startsWith: String
  dataObjectId_endsWith: String
  dataObjectId_in: [String!]
  happenedInId_eq: ID
  happenedInId_in: [ID!]
}

input JoystreamMediaLocationWhereUniqueInput {
  id: ID
  dataObjectId: String
}

type KnownLicense implements BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!

  """Short, commonly recognized code of the licence (ie. CC_BY_SA)"""
  code: String!

  """
  Full, descriptive name of the license (ie. Creative Commons - Attribution-NonCommercial-NoDerivs)
  """
  name: String

  """Short description of the license conditions"""
  description: String

  """An url pointing to full license content"""
  url: String
  happenedIn: Block
  happenedInId: String!
}

type KnownLicenseConnection {
  totalCount: Int!
  edges: [KnownLicenseEdge!]!
  pageInfo: PageInfo!
}

input KnownLicenseCreateInput {
  code: String!
  name: String
  description: String
  url: String
  happenedInId: ID!
}

type KnownLicenseEdge {
  node: KnownLicense!
  cursor: String!
}

enum KnownLicenseOrderByInput {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  code_ASC
  code_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  url_ASC
  url_DESC
  happenedInId_ASC
  happenedInId_DESC
}

input KnownLicenseUpdateInput {
  code: String
  name: String
  description: String
  url: String
  happenedInId: ID
}

input KnownLicenseWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  code_eq: String
  code_contains: String
  code_startsWith: String
  code_endsWith: String
  code_in: [String!]
  name_eq: String
  name_contains: String
  name_startsWith: String
  name_endsWith: String
  name_in: [String!]
  description_eq: String
  description_contains: String
  description_startsWith: String
  description_endsWith: String
  description_in: [String!]
  url_eq: String
  url_contains: String
  url_startsWith: String
  url_endsWith: String
  url_in: [String!]
  happenedInId_eq: ID
  happenedInId_in: [ID!]
}

input KnownLicenseWhereUniqueInput {
  id: ID
  code: String
}

type Language implements BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!
  name: String!
  code: String!
  happenedIn: Block
  happenedInId: String!
}

type LanguageConnection {
  totalCount: Int!
  edges: [LanguageEdge!]!
  pageInfo: PageInfo!
}

input LanguageCreateInput {
  name: String!
  code: String!
  happenedInId: ID!
}

type LanguageEdge {
  node: Language!
  cursor: String!
}

enum LanguageOrderByInput {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  name_ASC
  name_DESC
  code_ASC
  code_DESC
  happenedInId_ASC
  happenedInId_DESC
}

input LanguageUpdateInput {
  name: String
  code: String
  happenedInId: ID
}

input LanguageWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  name_eq: String
  name_contains: String
  name_startsWith: String
  name_endsWith: String
  name_in: [String!]
  code_eq: String
  code_contains: String
  code_startsWith: String
  code_endsWith: String
  code_in: [String!]
  happenedInId_eq: ID
  happenedInId_in: [ID!]
}

input LanguageWhereUniqueInput {
  id: ID!
}

"""Stored information about a registered user"""
type Member implements BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!

  """The unique handle chosen by member"""
  handle: String

  """A Url to member's Avatar image"""
  avatarUri: String

  """Short text chosen by member to share information about themselves"""
  about: String

  """Blocknumber when member was registered"""
  registeredAtBlock: Int!

  """Member's controller account id"""
  controllerAccount: String!

  """Member's root account id"""
  rootAccount: String!
  happenedIn: Block
  happenedInId: String!
}

type MemberConnection {
  totalCount: Int!
  edges: [MemberEdge!]!
  pageInfo: PageInfo!
}

input MemberCreateInput {
  handle: String
  avatarUri: String
  about: String
  registeredAtBlock: Float!
  controllerAccount: String!
  rootAccount: String!
  happenedInId: ID!
}

type MemberEdge {
  node: Member!
  cursor: String!
}

enum MemberOrderByInput {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  handle_ASC
  handle_DESC
  avatarUri_ASC
  avatarUri_DESC
  about_ASC
  about_DESC
  registeredAtBlock_ASC
  registeredAtBlock_DESC
  controllerAccount_ASC
  controllerAccount_DESC
  rootAccount_ASC
  rootAccount_DESC
  happenedInId_ASC
  happenedInId_DESC
}

input MemberUpdateInput {
  handle: String
  avatarUri: String
  about: String
  registeredAtBlock: Float
  controllerAccount: String
  rootAccount: String
  happenedInId: ID
}

input MemberWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  handle_eq: String
  handle_contains: String
  handle_startsWith: String
  handle_endsWith: String
  handle_in: [String!]
  avatarUri_eq: String
  avatarUri_contains: String
  avatarUri_startsWith: String
  avatarUri_endsWith: String
  avatarUri_in: [String!]
  about_eq: String
  about_contains: String
  about_startsWith: String
  about_endsWith: String
  about_in: [String!]
  registeredAtBlock_eq: Int
  registeredAtBlock_gt: Int
  registeredAtBlock_gte: Int
  registeredAtBlock_lt: Int
  registeredAtBlock_lte: Int
  registeredAtBlock_in: [Int!]
  controllerAccount_eq: String
  controllerAccount_contains: String
  controllerAccount_startsWith: String
  controllerAccount_endsWith: String
  controllerAccount_in: [String!]
  rootAccount_eq: String
  rootAccount_contains: String
  rootAccount_startsWith: String
  rootAccount_endsWith: String
  rootAccount_in: [String!]
  happenedInId_eq: ID
  happenedInId_in: [ID!]
}

input MemberWhereUniqueInput {
  id: ID
  handle: String
}

type NamesFTSOutput {
  item: NamesSearchResult!
  rank: Float!
  isTypeOf: String!
  highlight: String!
}

union NamesSearchResult = Category

enum Network {
  BABYLON
  ALEXANDRIA
  ROME
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  blocks(offset: Int, limit: Int = 50, where: BlockWhereInput, orderBy: BlockOrderByInput): [Block!]!
  blockConnection(first: Int, after: String, last: Int, before: String, where: BlockWhereInput, orderBy: BlockOrderByInput): BlockConnection!
  categorys(offset: Int, limit: Int = 50, where: CategoryWhereInput, orderBy: CategoryOrderByInput): [Category!]!
  categoryConnection(first: Int, after: String, last: Int, before: String, where: CategoryWhereInput, orderBy: CategoryOrderByInput): CategoryConnection!
  channels(offset: Int, limit: Int = 50, where: ChannelWhereInput, orderBy: ChannelOrderByInput): [Channel!]!
  channelConnection(first: Int, after: String, last: Int, before: String, where: ChannelWhereInput, orderBy: ChannelOrderByInput): ChannelConnection!
  classEntitys(offset: Int, limit: Int = 50, where: ClassEntityWhereInput, orderBy: ClassEntityOrderByInput): [ClassEntity!]!
  classEntityConnection(first: Int, after: String, last: Int, before: String, where: ClassEntityWhereInput, orderBy: ClassEntityOrderByInput): ClassEntityConnection!
  httpMediaLocations(offset: Int, limit: Int = 50, where: HttpMediaLocationWhereInput, orderBy: HttpMediaLocationOrderByInput): [HttpMediaLocation!]!
  httpMediaLocationConnection(first: Int, after: String, last: Int, before: String, where: HttpMediaLocationWhereInput, orderBy: HttpMediaLocationOrderByInput): HttpMediaLocationConnection!
  joystreamMediaLocations(offset: Int, limit: Int = 50, where: JoystreamMediaLocationWhereInput, orderBy: JoystreamMediaLocationOrderByInput): [JoystreamMediaLocation!]!
  joystreamMediaLocationConnection(first: Int, after: String, last: Int, before: String, where: JoystreamMediaLocationWhereInput, orderBy: JoystreamMediaLocationOrderByInput): JoystreamMediaLocationConnection!
  knownLicenses(offset: Int, limit: Int = 50, where: KnownLicenseWhereInput, orderBy: KnownLicenseOrderByInput): [KnownLicense!]!
  knownLicenseConnection(first: Int, after: String, last: Int, before: String, where: KnownLicenseWhereInput, orderBy: KnownLicenseOrderByInput): KnownLicenseConnection!
  languages(offset: Int, limit: Int = 50, where: LanguageWhereInput, orderBy: LanguageOrderByInput): [Language!]!
  languageConnection(first: Int, after: String, last: Int, before: String, where: LanguageWhereInput, orderBy: LanguageOrderByInput): LanguageConnection!
  members(offset: Int, limit: Int = 50, where: MemberWhereInput, orderBy: MemberOrderByInput): [Member!]!
  memberConnection(first: Int, after: String, last: Int, before: String, where: MemberWhereInput, orderBy: MemberOrderByInput): MemberConnection!
  handles(limit: Int = 5, text: String!): [HandlesFTSOutput!]!
  names(limit: Int = 5, text: String!): [NamesFTSOutput!]!
  titles(limit: Int = 5, text: String!): [TitlesFTSOutput!]!
  userDefinedLicenses(offset: Int, limit: Int = 50, where: UserDefinedLicenseWhereInput, orderBy: UserDefinedLicenseOrderByInput): [UserDefinedLicense!]!
  userDefinedLicenseConnection(first: Int, after: String, last: Int, before: String, where: UserDefinedLicenseWhereInput, orderBy: UserDefinedLicenseOrderByInput): UserDefinedLicenseConnection!
  videoMediaEncodings(offset: Int, limit: Int = 50, where: VideoMediaEncodingWhereInput, orderBy: VideoMediaEncodingOrderByInput): [VideoMediaEncoding!]!
  videoMediaEncodingConnection(first: Int, after: String, last: Int, before: String, where: VideoMediaEncodingWhereInput, orderBy: VideoMediaEncodingOrderByInput): VideoMediaEncodingConnection!
  videoMedias(offset: Int, limit: Int = 50, where: VideoMediaWhereInput, orderBy: VideoMediaOrderByInput): [VideoMedia!]!
  videoMediaConnection(first: Int, after: String, last: Int, before: String, where: VideoMediaWhereInput, orderBy: VideoMediaOrderByInput): VideoMediaConnection!
  videos(offset: Int, limit: Int = 50, where: VideoWhereInput, orderBy: VideoOrderByInput): [Video!]!
  videoConnection(first: Int, after: String, last: Int, before: String, where: VideoWhereInput, orderBy: VideoOrderByInput): VideoConnection!
}

type StandardDeleteResponse {
  id: ID!
}

type TitlesFTSOutput {
  item: TitlesSearchResult!
  rank: Float!
  isTypeOf: String!
  highlight: String!
}

union TitlesSearchResult = Channel | Video

type UserDefinedLicense implements BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!

  """Custom license content"""
  content: String!
  happenedIn: Block
  happenedInId: String!
}

type UserDefinedLicenseConnection {
  totalCount: Int!
  edges: [UserDefinedLicenseEdge!]!
  pageInfo: PageInfo!
}

input UserDefinedLicenseCreateInput {
  content: String!
  happenedInId: ID!
}

type UserDefinedLicenseEdge {
  node: UserDefinedLicense!
  cursor: String!
}

enum UserDefinedLicenseOrderByInput {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  content_ASC
  content_DESC
  happenedInId_ASC
  happenedInId_DESC
}

input UserDefinedLicenseUpdateInput {
  content: String
  happenedInId: ID
}

input UserDefinedLicenseWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  content_eq: String
  content_contains: String
  content_startsWith: String
  content_endsWith: String
  content_in: [String!]
  happenedInId_eq: ID
  happenedInId_in: [ID!]
}

input UserDefinedLicenseWhereUniqueInput {
  id: ID!
}

type Video implements BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!

  """Reference to member's channel"""
  channelId: Int!

  """Reference to a video category"""
  categoryId: Int!

  """The title of the video"""
  title: String!

  """The description of the Video"""
  description: String!

  """Video duration in seconds"""
  duration: Int!

  """Video's skippable intro duration in seconds"""
  skippableIntroDuration: Int

  """Video thumbnail url (recommended ratio: 16:9)"""
  thumbnailUrl: String!

  """Video's main langauge"""
  languageId: Int

  """Reference to VideoMedia"""
  videoMediaId: Int!

  """Whether or not Video contains marketing"""
  hasMarketing: Boolean

  """
  If the Video was published on other platform before beeing published on Joystream - the original publication date
  """
  publishedBeforeJoystream: Int

  """Whether the Video is supposed to be publically displayed"""
  isPublic: Boolean!

  """Video curation status set by the Curator"""
  isCurated: Boolean!

  """Whether the Video contains explicit material."""
  isExplicit: Boolean!
  licenseId: Int!
  happenedIn: Block
  happenedInId: String!
}

type VideoConnection {
  totalCount: Int!
  edges: [VideoEdge!]!
  pageInfo: PageInfo!
}

input VideoCreateInput {
  channelId: Float!
  categoryId: Float!
  title: String!
  description: String!
  duration: Float!
  skippableIntroDuration: Float
  thumbnailUrl: String!
  languageId: Float
  videoMediaId: Float!
  hasMarketing: Boolean
  publishedBeforeJoystream: Float
  isPublic: Boolean!
  isCurated: Boolean!
  isExplicit: Boolean!
  licenseId: Float!
  happenedInId: ID!
}

type VideoEdge {
  node: Video!
  cursor: String!
}

type VideoMedia implements BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!

  """Encoding of the video media object"""
  encodingId: Int!

  """Video media width in pixels"""
  pixelWidth: Int!

  """Video media height in pixels"""
  pixelHeight: Int!

  """Video media size in bytes"""
  size: Int
  locationId: Int!
  happenedIn: Block
  happenedInId: String!
}

type VideoMediaConnection {
  totalCount: Int!
  edges: [VideoMediaEdge!]!
  pageInfo: PageInfo!
}

input VideoMediaCreateInput {
  encodingId: Float!
  pixelWidth: Float!
  pixelHeight: Float!
  size: Float
  locationId: Float!
  happenedInId: ID!
}

type VideoMediaEdge {
  node: VideoMedia!
  cursor: String!
}

"""Encoding and containers"""
type VideoMediaEncoding implements BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!
  name: String!
}

type VideoMediaEncodingConnection {
  totalCount: Int!
  edges: [VideoMediaEncodingEdge!]!
  pageInfo: PageInfo!
}

input VideoMediaEncodingCreateInput {
  name: String!
}

type VideoMediaEncodingEdge {
  node: VideoMediaEncoding!
  cursor: String!
}

enum VideoMediaEncodingOrderByInput {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  name_ASC
  name_DESC
}

input VideoMediaEncodingUpdateInput {
  name: String
}

input VideoMediaEncodingWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  name_eq: String
  name_contains: String
  name_startsWith: String
  name_endsWith: String
  name_in: [String!]
}

input VideoMediaEncodingWhereUniqueInput {
  id: ID!
}

enum VideoMediaOrderByInput {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  encodingId_ASC
  encodingId_DESC
  pixelWidth_ASC
  pixelWidth_DESC
  pixelHeight_ASC
  pixelHeight_DESC
  size_ASC
  size_DESC
  locationId_ASC
  locationId_DESC
  happenedInId_ASC
  happenedInId_DESC
}

input VideoMediaUpdateInput {
  encodingId: Float
  pixelWidth: Float
  pixelHeight: Float
  size: Float
  locationId: Float
  happenedInId: ID
}

input VideoMediaWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  encodingId_eq: Int
  encodingId_gt: Int
  encodingId_gte: Int
  encodingId_lt: Int
  encodingId_lte: Int
  encodingId_in: [Int!]
  pixelWidth_eq: Int
  pixelWidth_gt: Int
  pixelWidth_gte: Int
  pixelWidth_lt: Int
  pixelWidth_lte: Int
  pixelWidth_in: [Int!]
  pixelHeight_eq: Int
  pixelHeight_gt: Int
  pixelHeight_gte: Int
  pixelHeight_lt: Int
  pixelHeight_lte: Int
  pixelHeight_in: [Int!]
  size_eq: Int
  size_gt: Int
  size_gte: Int
  size_lt: Int
  size_lte: Int
  size_in: [Int!]
  locationId_eq: Int
  locationId_gt: Int
  locationId_gte: Int
  locationId_lt: Int
  locationId_lte: Int
  locationId_in: [Int!]
  happenedInId_eq: ID
  happenedInId_in: [ID!]
}

input VideoMediaWhereUniqueInput {
  id: ID!
}

enum VideoOrderByInput {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  channelId_ASC
  channelId_DESC
  categoryId_ASC
  categoryId_DESC
  title_ASC
  title_DESC
  description_ASC
  description_DESC
  duration_ASC
  duration_DESC
  skippableIntroDuration_ASC
  skippableIntroDuration_DESC
  thumbnailUrl_ASC
  thumbnailUrl_DESC
  languageId_ASC
  languageId_DESC
  videoMediaId_ASC
  videoMediaId_DESC
  hasMarketing_ASC
  hasMarketing_DESC
  publishedBeforeJoystream_ASC
  publishedBeforeJoystream_DESC
  isPublic_ASC
  isPublic_DESC
  isCurated_ASC
  isCurated_DESC
  isExplicit_ASC
  isExplicit_DESC
  licenseId_ASC
  licenseId_DESC
  happenedInId_ASC
  happenedInId_DESC
}

input VideoUpdateInput {
  channelId: Float
  categoryId: Float
  title: String
  description: String
  duration: Float
  skippableIntroDuration: Float
  thumbnailUrl: String
  languageId: Float
  videoMediaId: Float
  hasMarketing: Boolean
  publishedBeforeJoystream: Float
  isPublic: Boolean
  isCurated: Boolean
  isExplicit: Boolean
  licenseId: Float
  happenedInId: ID
}

input VideoWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  channelId_eq: Int
  channelId_gt: Int
  channelId_gte: Int
  channelId_lt: Int
  channelId_lte: Int
  channelId_in: [Int!]
  categoryId_eq: Int
  categoryId_gt: Int
  categoryId_gte: Int
  categoryId_lt: Int
  categoryId_lte: Int
  categoryId_in: [Int!]
  title_eq: String
  title_contains: String
  title_startsWith: String
  title_endsWith: String
  title_in: [String!]
  description_eq: String
  description_contains: String
  description_startsWith: String
  description_endsWith: String
  description_in: [String!]
  duration_eq: Int
  duration_gt: Int
  duration_gte: Int
  duration_lt: Int
  duration_lte: Int
  duration_in: [Int!]
  skippableIntroDuration_eq: Int
  skippableIntroDuration_gt: Int
  skippableIntroDuration_gte: Int
  skippableIntroDuration_lt: Int
  skippableIntroDuration_lte: Int
  skippableIntroDuration_in: [Int!]
  thumbnailUrl_eq: String
  thumbnailUrl_contains: String
  thumbnailUrl_startsWith: String
  thumbnailUrl_endsWith: String
  thumbnailUrl_in: [String!]
  languageId_eq: Int
  languageId_gt: Int
  languageId_gte: Int
  languageId_lt: Int
  languageId_lte: Int
  languageId_in: [Int!]
  videoMediaId_eq: Int
  videoMediaId_gt: Int
  videoMediaId_gte: Int
  videoMediaId_lt: Int
  videoMediaId_lte: Int
  videoMediaId_in: [Int!]
  hasMarketing_eq: Boolean
  hasMarketing_in: [Boolean!]
  publishedBeforeJoystream_eq: Int
  publishedBeforeJoystream_gt: Int
  publishedBeforeJoystream_gte: Int
  publishedBeforeJoystream_lt: Int
  publishedBeforeJoystream_lte: Int
  publishedBeforeJoystream_in: [Int!]
  isPublic_eq: Boolean
  isPublic_in: [Boolean!]
  isCurated_eq: Boolean
  isCurated_in: [Boolean!]
  isExplicit_eq: Boolean
  isExplicit_in: [Boolean!]
  licenseId_eq: Int
  licenseId_gt: Int
  licenseId_gte: Int
  licenseId_lt: Int
  licenseId_lte: Int
  licenseId_in: [Int!]
  happenedInId_eq: ID
  happenedInId_in: [ID!]
}

input VideoWhereUniqueInput {
  id: ID!
}
